







<!DOCTYPE HTML>
<html lang="zh_CN">
<head>
  <meta charset="UTF-8">
  <title>微信客户端sql抓取 - 记录-好好工作</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1">
  
  <title>微信客户端sql抓取</title>
  <meta name="description" content="  微信抓取最稳定的方法是客户端抓取，但这也是最困难的抓取方法，这里提供一个抓取的思路。
 抓取背景  微信客户端（Android）的推送服务是长连接，但是并不能保证公众账号的文章能够及时或者优先被推送； 长连接的每次心跳推送会修改/data/data/con.tencent.mm/MicroMsg/{hash}/EnMicroMsg.db; 该db是使用sqlcipher开源工具加密，注意是db加密，并不是数据加密； db的加密密码是hash(IMEI&#43;UIN)[:7]； IMEI即手机的串号，UIN为微信账号的内部ID，IMEI能直接在手机内读取，UIN能在手机内读取最后一次登录的账号的。  抓取思路 主要思路是读取EnMicroMsg.db这个数据库的内容， 公众账号的文章同样是在message表中， 据此便能在不影响微信的情况下，很顺利的拿到推送消息（不是内容）。
对于推送的及时性，思路可以是这样，监测这个EnMicroMsg.db文件， 如果在*分钟内没有修改，那就启动微信的主activity，等待一定时间后再销毁（或不销毁）。
启动方法：
am start -n com.tencent.mm/com.tencent.mm.UI.Launcher  研究进度 现在能够查看message表中内容，公众号的消息会在以下两个Field中区别于普通消息：
{ &quot;content&quot;: &quot;~SEMI_XML~&quot;, //暂时不确定这个是string还是data &quot;bizClientMsgId&quot;: &quot;mmbizcluster_1_3077155302_405050727&quot; }  其中bizClientMsgId是重点，因为在该数据库（其他的Index，Sns不是消息内容）并不能直接找到文章的url，abstrac等。 推测，url是由这个字段拼接而成。
 rconversation表同样有记录消息（摘要）。
 完整的url如下，
http://mp.weixin.qq.com/s?__biz=MzA3NzE1NTMwMg==&amp;mid=2650660112&amp;idx=1&amp;sn=b041276dd158bf917b195b33ec9ef2c6  其中，
 __biz为公众号id的base64编码值，即上面示例的bizClientMsgId字段中的3077155302， mid暂时还没有找到， idx为bizClientMsgId字段中的1， sn应该是上面三个值某种算法的hash值，服务端根据这个值来做校验。  所遇问题  bizClientMsgId中的405050727还没有参与计算，同时url中的mid不知从何计算，从某种角度来说，这两个值应该是有关系的；
 暂时还没有校验参数sn的具体计算方法。
   目前还不清楚web端返回的是不是直接的url，如果不是可以在js上找到计算方法； 如果不行，只有反编译apk
 ">
  
  <meta name="author" content="">
  <meta name="keywords" content="">
  <link rel="icon" href="/favicon.png">
  
  
  <meta itemprop="name" content="微信客户端sql抓取 - 记录-好好工作">
  <meta itemprop="description" content="  微信抓取最稳定的方法是客户端抓取，但这也是最困难的抓取方法，这里提供一个抓取的思路。
 抓取背景  微信客户端（Android）的推送服务是长连接，但是并不能保证公众账号的文章能够及时或者优先被推送； 长连接的每次心跳推送会修改/data/data/con.tencent.mm/MicroMsg/{hash}/EnMicroMsg.db; 该db是使用sqlcipher开源工具加密，注意是db加密，并不是数据加密； db的加密密码是hash(IMEI&#43;UIN)[:7]； IMEI即手机的串号，UIN为微信账号的内部ID，IMEI能直接在手机内读取，UIN能在手机内读取最后一次登录的账号的。  抓取思路 主要思路是读取EnMicroMsg.db这个数据库的内容， 公众账号的文章同样是在message表中， 据此便能在不影响微信的情况下，很顺利的拿到推送消息（不是内容）。
对于推送的及时性，思路可以是这样，监测这个EnMicroMsg.db文件， 如果在*分钟内没有修改，那就启动微信的主activity，等待一定时间后再销毁（或不销毁）。
启动方法：
am start -n com.tencent.mm/com.tencent.mm.UI.Launcher  研究进度 现在能够查看message表中内容，公众号的消息会在以下两个Field中区别于普通消息：
{ &quot;content&quot;: &quot;~SEMI_XML~&quot;, //暂时不确定这个是string还是data &quot;bizClientMsgId&quot;: &quot;mmbizcluster_1_3077155302_405050727&quot; }  其中bizClientMsgId是重点，因为在该数据库（其他的Index，Sns不是消息内容）并不能直接找到文章的url，abstrac等。 推测，url是由这个字段拼接而成。
 rconversation表同样有记录消息（摘要）。
 完整的url如下，
http://mp.weixin.qq.com/s?__biz=MzA3NzE1NTMwMg==&amp;mid=2650660112&amp;idx=1&amp;sn=b041276dd158bf917b195b33ec9ef2c6  其中，
 __biz为公众号id的base64编码值，即上面示例的bizClientMsgId字段中的3077155302， mid暂时还没有找到， idx为bizClientMsgId字段中的1， sn应该是上面三个值某种算法的hash值，服务端根据这个值来做校验。  所遇问题  bizClientMsgId中的405050727还没有参与计算，同时url中的mid不知从何计算，从某种角度来说，这两个值应该是有关系的；
 暂时还没有校验参数sn的具体计算方法。
   目前还不清楚web端返回的是不是直接的url，如果不是可以在js上找到计算方法； 如果不行，只有反编译apk
 ">
  <meta itemprop="image" content="img/author.jpg">
  
  
  <meta name="twitter:description" content="">
  
  <link rel="shortcut icon" href="img/favicon.ico"/>
  <link rel="apple-touch-icon" href="apple-touch-icon.png" />
  <link rel="apple-touch-icon-precomposed" href="apple-touch-icon.png" />

  
  <meta name="description" content="  微信抓取最稳定的方法是客户端抓取，但这也是最困难的抓取方法，这里提供一个抓取的思路。
 抓取背景  微信客户端（Android）的推送服务是长连接，但是并不能保证公众账号的文章能够及时或者优先被推送； 长连接的每次心跳推送会修改/data/data/con.tencent.mm/MicroMsg/{hash}/EnMicroMsg.db; 该db是使用sqlcipher开源工具加密，注意是db加密，并不是数据加密； db的加密密码是hash(IMEI&#43;UIN)[:7]； IMEI即手机的串号，UIN为微信账号的内部ID，IMEI能直接在手机内读取，UIN能在手机内读取最后一次登录的账号的。  抓取思路 主要思路是读取EnMicroMsg.db这个数据库的内容， 公众账号的文章同样是在message表中， 据此便能在不影响微信的情况下，很顺利的拿到推送消息（不是内容）。
对于推送的及时性，思路可以是这样，监测这个EnMicroMsg.db文件， 如果在*分钟内没有修改，那就启动微信的主activity，等待一定时间后再销毁（或不销毁）。
启动方法：
am start -n com.tencent.mm/com.tencent.mm.UI.Launcher  研究进度 现在能够查看message表中内容，公众号的消息会在以下两个Field中区别于普通消息：
{ &quot;content&quot;: &quot;~SEMI_XML~&quot;, //暂时不确定这个是string还是data &quot;bizClientMsgId&quot;: &quot;mmbizcluster_1_3077155302_405050727&quot; }  其中bizClientMsgId是重点，因为在该数据库（其他的Index，Sns不是消息内容）并不能直接找到文章的url，abstrac等。 推测，url是由这个字段拼接而成。
 rconversation表同样有记录消息（摘要）。
 完整的url如下，
http://mp.weixin.qq.com/s?__biz=MzA3NzE1NTMwMg==&amp;mid=2650660112&amp;idx=1&amp;sn=b041276dd158bf917b195b33ec9ef2c6  其中，
 __biz为公众号id的base64编码值，即上面示例的bizClientMsgId字段中的3077155302， mid暂时还没有找到， idx为bizClientMsgId字段中的1， sn应该是上面三个值某种算法的hash值，服务端根据这个值来做校验。  所遇问题  bizClientMsgId中的405050727还没有参与计算，同时url中的mid不知从何计算，从某种角度来说，这两个值应该是有关系的；
 暂时还没有校验参数sn的具体计算方法。
   目前还不清楚web端返回的是不是直接的url，如果不是可以在js上找到计算方法； 如果不行，只有反编译apk
 ">
  <meta property="og:description" content="  微信抓取最稳定的方法是客户端抓取，但这也是最困难的抓取方法，这里提供一个抓取的思路。
 抓取背景  微信客户端（Android）的推送服务是长连接，但是并不能保证公众账号的文章能够及时或者优先被推送； 长连接的每次心跳推送会修改/data/data/con.tencent.mm/MicroMsg/{hash}/EnMicroMsg.db; 该db是使用sqlcipher开源工具加密，注意是db加密，并不是数据加密； db的加密密码是hash(IMEI&#43;UIN)[:7]； IMEI即手机的串号，UIN为微信账号的内部ID，IMEI能直接在手机内读取，UIN能在手机内读取最后一次登录的账号的。  抓取思路 主要思路是读取EnMicroMsg.db这个数据库的内容， 公众账号的文章同样是在message表中， 据此便能在不影响微信的情况下，很顺利的拿到推送消息（不是内容）。
对于推送的及时性，思路可以是这样，监测这个EnMicroMsg.db文件， 如果在*分钟内没有修改，那就启动微信的主activity，等待一定时间后再销毁（或不销毁）。
启动方法：
am start -n com.tencent.mm/com.tencent.mm.UI.Launcher  研究进度 现在能够查看message表中内容，公众号的消息会在以下两个Field中区别于普通消息：
{ &quot;content&quot;: &quot;~SEMI_XML~&quot;, //暂时不确定这个是string还是data &quot;bizClientMsgId&quot;: &quot;mmbizcluster_1_3077155302_405050727&quot; }  其中bizClientMsgId是重点，因为在该数据库（其他的Index，Sns不是消息内容）并不能直接找到文章的url，abstrac等。 推测，url是由这个字段拼接而成。
 rconversation表同样有记录消息（摘要）。
 完整的url如下，
http://mp.weixin.qq.com/s?__biz=MzA3NzE1NTMwMg==&amp;mid=2650660112&amp;idx=1&amp;sn=b041276dd158bf917b195b33ec9ef2c6  其中，
 __biz为公众号id的base64编码值，即上面示例的bizClientMsgId字段中的3077155302， mid暂时还没有找到， idx为bizClientMsgId字段中的1， sn应该是上面三个值某种算法的hash值，服务端根据这个值来做校验。  所遇问题  bizClientMsgId中的405050727还没有参与计算，同时url中的mid不知从何计算，从某种角度来说，这两个值应该是有关系的；
 暂时还没有校验参数sn的具体计算方法。
   目前还不清楚web端返回的是不是直接的url，如果不是可以在js上找到计算方法； 如果不行，只有反编译apk
 ">
  <meta property="og:type" content="blog">
  <meta property="og:title" content="微信客户端sql抓取">
  <meta property="og:url" content="/w/post/2016-4-17-weixin-articles/">
  <meta property="og:site_name" content="记录-好好工作">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="记录-好好工作">
  <meta name="twitter:description" content="  微信抓取最稳定的方法是客户端抓取，但这也是最困难的抓取方法，这里提供一个抓取的思路。
 抓取背景  微信客户端（Android）的推送服务是长连接，但是并不能保证公众账号的文章能够及时或者优先被推送； 长连接的每次心跳推送会修改/data/data/con.tencent.mm/MicroMsg/{hash}/EnMicroMsg.db; 该db是使用sqlcipher开源工具加密，注意是db加密，并不是数据加密； db的加密密码是hash(IMEI&#43;UIN)[:7]； IMEI即手机的串号，UIN为微信账号的内部ID，IMEI能直接在手机内读取，UIN能在手机内读取最后一次登录的账号的。  抓取思路 主要思路是读取EnMicroMsg.db这个数据库的内容， 公众账号的文章同样是在message表中， 据此便能在不影响微信的情况下，很顺利的拿到推送消息（不是内容）。
对于推送的及时性，思路可以是这样，监测这个EnMicroMsg.db文件， 如果在*分钟内没有修改，那就启动微信的主activity，等待一定时间后再销毁（或不销毁）。
启动方法：
am start -n com.tencent.mm/com.tencent.mm.UI.Launcher  研究进度 现在能够查看message表中内容，公众号的消息会在以下两个Field中区别于普通消息：
{ &quot;content&quot;: &quot;~SEMI_XML~&quot;, //暂时不确定这个是string还是data &quot;bizClientMsgId&quot;: &quot;mmbizcluster_1_3077155302_405050727&quot; }  其中bizClientMsgId是重点，因为在该数据库（其他的Index，Sns不是消息内容）并不能直接找到文章的url，abstrac等。 推测，url是由这个字段拼接而成。
 rconversation表同样有记录消息（摘要）。
 完整的url如下，
http://mp.weixin.qq.com/s?__biz=MzA3NzE1NTMwMg==&amp;mid=2650660112&amp;idx=1&amp;sn=b041276dd158bf917b195b33ec9ef2c6  其中，
 __biz为公众号id的base64编码值，即上面示例的bizClientMsgId字段中的3077155302， mid暂时还没有找到， idx为bizClientMsgId字段中的1， sn应该是上面三个值某种算法的hash值，服务端根据这个值来做校验。  所遇问题  bizClientMsgId中的405050727还没有参与计算，同时url中的mid不知从何计算，从某种角度来说，这两个值应该是有关系的；
 暂时还没有校验参数sn的具体计算方法。
   目前还不清楚web端返回的是不是直接的url，如果不是可以在js上找到计算方法； 如果不行，只有反编译apk
 ">
  
  

  
  

  

  
  
  

  

  
  
    <link rel="stylesheet" href="https://zi.com/w/css/public.min.css">
  
  

  
  
  
  

  
    
  
</head>
<body>
    
        
    
    <div class="container">
        

<blockquote>
<p>微信抓取最稳定的方法是客户端抓取，但这也是最困难的抓取方法，这里提供一个抓取的思路。</p>
</blockquote>

<h3 id="抓取背景">抓取背景</h3>

<ul>
<li>微信客户端（Android）的推送服务是长连接，但是并不能保证公众账号的文章能够及时或者优先被推送；</li>
<li>长连接的每次心跳推送会修改<code>/data/data/con.tencent.mm/MicroMsg/{hash}/EnMicroMsg.db</code>;</li>
<li>该db是使用<code>sqlcipher</code>开源工具加密，注意是db加密，并不是数据加密；</li>
<li>db的加密密码是<code>hash(IMEI+UIN)[:7]</code>；</li>
<li>IMEI即手机的串号，UIN为微信账号的内部ID，IMEI能直接在手机内读取，UIN能在手机内读取最后一次登录的账号的。</li>
</ul>

<h3 id="抓取思路">抓取思路</h3>

<p>主要思路是读取EnMicroMsg.db这个数据库的内容，
公众账号的文章同样是在message表中，
据此便能在不影响微信的情况下，很顺利的拿到推送消息（不是内容）。</p>

<p>对于推送的及时性，思路可以是这样，监测这个EnMicroMsg.db文件，
如果在*分钟内没有修改，那就启动微信的主activity，等待一定时间后再销毁（或不销毁）。</p>

<p>启动方法：</p>

<pre><code class="language-bash">am start -n com.tencent.mm/com.tencent.mm.UI.Launcher
</code></pre>

<h3 id="研究进度">研究进度</h3>

<p>现在能够查看message表中内容，公众号的消息会在以下两个Field中区别于普通消息：</p>

<pre><code class="language-json">{
    &quot;content&quot;: &quot;~SEMI_XML~&quot;, //暂时不确定这个是string还是data
    &quot;bizClientMsgId&quot;: &quot;mmbizcluster_1_3077155302_405050727&quot;
}
</code></pre>

<p>其中<code>bizClientMsgId</code>是重点，因为在该数据库（其他的Index，Sns不是消息内容）并不能直接找到文章的url，abstrac等。
推测，url是由这个字段拼接而成。</p>

<blockquote>
<p><code>rconversation</code>表同样有记录消息（摘要）。</p>
</blockquote>

<p>完整的url如下，</p>

<pre><code>http://mp.weixin.qq.com/s?__biz=MzA3NzE1NTMwMg==&amp;mid=2650660112&amp;idx=1&amp;sn=b041276dd158bf917b195b33ec9ef2c6
</code></pre>

<p>其中，</p>

<ul>
<li><code>__biz</code>为公众号id的base64编码值，即上面示例的<code>bizClientMsgId</code>字段中的<code>3077155302</code>，</li>
<li><code>mid</code>暂时还没有找到，</li>
<li><code>idx</code>为<code>bizClientMsgId</code>字段中的<code>1</code>，</li>
<li><code>sn</code>应该是上面三个值某种算法的hash值，服务端根据这个值来做校验。</li>
</ul>

<h3 id="所遇问题">所遇问题</h3>

<ul>
<li><p><code>bizClientMsgId</code>中的<code>405050727</code>还没有参与计算，同时url中的<code>mid</code>不知从何计算，从某种角度来说，这两个值应该是有关系的；</p></li>

<li><p>暂时还没有校验参数<code>sn</code>的具体计算方法。</p></li>
</ul>

<blockquote>
<p>目前还不清楚web端返回的是不是直接的url，如果不是可以在js上找到计算方法；
如果不行，只有反编译apk</p>
</blockquote>

    </div>
</body>

  

</html>